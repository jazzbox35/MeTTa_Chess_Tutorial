\documentclass{article}

% ----------- core mathematics -----------
\usepackage{amsmath}   % align, split, cases, etc.
\usepackage{amssymb}   % \mathbb, \mathcal, \leqslant, \geqslant ...
\usepackage{amsfonts}  % blackboard bold, fraktur if desired
\usepackage{graphicx}  % for future figures, even if none are included yet
\usepackage{listings}  % for code examples
\usepackage{hyperref}  % clickable cross-refs; load last
\usepackage{mdframed}  % for boxed content

% ----------- tables & arrays ------------
\usepackage{array}     % extended column specifiers in tabular
\usepackage{booktabs}  % nicer horizontal rules (optional; you may keep \hline)
\usepackage{multirow}  % multi-row cells if you extend the tables later

% ----------- layout & floats ------------
\usepackage{geometry}  % easy margin control (defaults are fine; optional)
\usepackage{caption}   % better caption spacing for tables/figures

\title{What is MeTTa and why use it?}
\order{1}
\author{Tutorial Team}
\date{May 21, 2025}

\begin{document}


\section{What is MeTTa and why use it?}

\subsection{It Might Not Be Clear What MeTTa Is}

Perhaps you heard about MeTTa on social media, at a conference, or from a colleague, and want to explore. You heard it is an innovative AI language that would benefit your projects. 

You probably have some questions in mind such as:

\begin{itemize}
  \item What is the use of a symbolic AI language in an LLM age? Why learn it?
  \item Is MeTTa a LISP variant? Is it just LISP reincarnated slightly differently?
  \item How do I install MeTTa on my machine?
  \item How can I understand the code? How many constructs do I really need for coding?
  \item What does "MeTTa" mean?
  \item Somebody said it was too slow. Is that true?
\end{itemize}

Well, if you have variations of these questions, you are on the right tutorial!


\subsection{Distinguishing MeTTa Characteristics}

The single most defining characteristic of MeTTa is this: it insists on giving you all possible results.

Suppose you are creating a package delivery routing application. Given a starting point and a destination, let's say ten routes exist, each with many twists and turns. MeTTa can give you all complete routes. 







\subsubsection{AtomSpace}

The \textbf{AtomSpace} is Hyperon's persistent metagraph store.  Every node and link you mine lives there.  In MeTTa you typically create or bind an AtomSpace via:

\begin{verbatim}
!(import! &self hyperon-miner:match:MinerMatch)
!(bind! &atom-space (new-space)) 
\end{verbatim}

Atoms you insert may be of various types, such as

\begin{itemize}
  \item \texttt{ConceptNode}: \verb|Coke|
  \item \texttt{LinkNode}: \verb|drink|
  \item \texttt{VariableNode}:  \verb|$X|
  \item \texttt{InheritanceLink}: 
    \verb|(Inheritance $X American)|
  \item \texttt{EvaluationLink}:  
    \verb|(drink $X Coke)|
\end{itemize}

\subsubsection{Abstract vs. Specialized Patterns}

The miner distinguishes between \emph{abstract} and \emph{specialized} patterns:

\begin{enumerate}
  \item \textbf{Abstract patterns}
  Generated by scanning for unique link nodes and creating a pattern with the link node and Variable nodes and checking for the support of the pattern generated to see if it satisfies the minimum support threshold to prevent an abstract pattern that doesn't satisfy the minimum support threshold from being specialized.  Implemented by the \texttt{abstract-pattern} logic in \texttt{experiments/rules/frequent-pattern-miner.metta}
    \begin{verbatim}
;; returns abstract patterns
!(abstract-pattern $dbspace $minsup $aptrnspace)
    \end{verbatim}
  \item \textbf{Specialized patterns}
    Each abstract pattern is ''specialized'' by composing a variable with shallow abstractions of its groundings/valuations/substitutions.  This is done in \texttt{experiments/rules/build-specialization.metta} using the \texttt{build-specialization} function.
\end{enumerate}

We now look at some examples of each of these.

\paragraph{Abstract Patterns}

Below are two concrete examples showing how a ground link is turned into Abstract patterns.

\paragraph{Example 1:}

Suppose the AtomSpace contains the ground atom:

\begin{verbatim}
(drink Alice Coke)
\end{verbatim}

The abstract pattern generated by \texttt{(abstract-pattern)} is:

\begin{verbatim}
(drink $x $y)
\end{verbatim}

\paragraph{Example 2:}

Given the ground atom:

\begin{verbatim}
(inherit Alice American)
\end{verbatim}

The abstract pattern generated is:

\begin{verbatim}
(inherit $x $y)
\end{verbatim}

To check it out first load the neccessary components.


\begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:frequent-pattern-miner)
!(import! &self hyperon-miner:experiments:utils:common-utils)
\end{verbatim}

Create new atom space and load some ground atoms.


\begin{verbatim}
;; create db space 
!(bind! &db (new-space))
!(add-reduct &db (superpose ((drink Alice Coke)
                                   (drink Bob Coke)
                                   (drink Alice Tea)
                                   (drink Bob Tea)
                                    (drink Carol Tea))))
                                    
;;Create a new space for the result                                   
!(bind! &aptrnspace (new-space))
\end{verbatim}

    \begin{verbatim}
;; returns abstract patterns
!(abstract-pattern &db 2 &aptrnspace)
!(match &aptrnspace $x $x )
    \end{verbatim}

\subsubsection{Examples of Specialized Patterns}

Below are two concrete examples showing how an \texttt{abstract} pattern is turned into \texttt{specialized} patterns via the \texttt{build-specialization} function.

\paragraph{Example 1: Drink Pattern}

Suppose your AtomSpace contains these ground atoms:

\begin{verbatim}
(drink Alice Coke)
(drink Bob Coke)
(drink Carol Tea)
\end{verbatim}

We can then

\begin{enumerate}
\item  Define the abstract pattern:
    \begin{verbatim}
 (=(p_abs)(drink $X $Y))
    \end{verbatim}
\item  Specialize to get each grounding:
    \begin{verbatim}
    (specialize atom-space (p_abs))
     ;; The result would look like 
         (SpecializationOf (drink Alice $Y) (drink $x $y))
         (SpecializationOf (drink Bob $Y) (drink $x $y))
         (SpecializationOf (drink $X Coke)  (drink $x $y))
         (SpecializationOf (drink $X Tea) (drink $x $y))
    \end{verbatim}
\item   Group and count via support:
    \begin{verbatim}
(support p_spec 2)
    \end{verbatim}
    This indicates the pattern ''drinks \$X  Coke'' occurs twice.
\end{enumerate}

Now let's try it with the actual build-specialization function.
First, import the build-specialization component and create a new space to store the result.

 \begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:build-specialization)
!(bind! &specspace (new-space))
  \end{verbatim}

Since we have obtained the abstract pattern from our previous example, we can provide it  to the function.

 \begin{verbatim}
;;returns all possible specializations of the abstract pattern
!(build-specialization (drink Z (S Z)) &db &specspace)
!(match &specspace $x $x)
  \end{verbatim}



\subsubsection{Candidate Patterns and Support}

A \emph{candidate pattern} is any specialized pattern whose \emph{support} \space{0.2rem} \textbf{match-count} meets your minimum threshold:

import the candidate-patterns function and create a new space to store the result.

 \begin{verbatim}
!(import! &self hyperon-miner:experiments:rules:candidate-patterns)
!(bind! &cndpspace (new-space))
  \end{verbatim}

\begin{verbatim}
!(candidatePattern &db &specspace 2 &cndpspace)
!(match &cndpspace $x $x)
\end{verbatim}

Here:\\

\begin{itemize}
  \item \texttt{minsup} is the minimum support parameter.
  \item \texttt{support} invokes \texttt{count} and filters out patterns with count < \texttt{minsup}.
\end{itemize}

\subsubsection{Conjunction and Pattern Expansion}

To discover richer structures, surviving patterns are greedily expanded by conjunction:


\section{Implementation Details}

This whole process is implemented in MeTTa, so if one runs it within a fast MeTTa interpretation or compilation framework, it should scale to huge numbers  of Atoms.  (Different Atoms may have different sizes, but very roughly, in a server with terabytes of RAM one may be able to host Atomspaces with 100B or more Atoms.)   It also exposes a clean API so you can integrate pattern mining directly into larger learning or reasoning pipelines.

\subsection{Current Capabilities and Future Work}

In its current form the Pattern Miner runs against an Atomspace in RAM on a single machine, however the underlying algorithms are well designed for extension to a distributed-processing setting, and we anticipate future Pattern Miner versions working effectlvely on distributed Atomspaces as well.   This further development will be done in conjunction with other existing tools like the Distributed Atomspace (DAS) XX and the Mettacycle decentralized infrastructure (XX).

\subsection{The Atomspace You Will Be Working On}

All of the live examples on this tutorial operate within a single AtomSpace. As you run each code example, or "cell," you are continuously adding new information to this space, building upon the results from all the cells you have already run. The "Reset Atomspace" button wipes the whole atomspace and lets you start on a clean slate whilst the "reset" button on the cells (code snippets) themselves  provide a way to start over from that specific point whilst maintaing the state of the atom upto that particular snippet. The most common use case for these buttons is if you happen to be facing an import issue at some point you could reset the whole atomspace or reset the snippet that executes the importing tasks so that subsequent cells can get the correct imports they need. 

\section{Tutorial Objectives}

In this tutorial you will learn to:

\begin{enumerate}
  \item \textbf{Ground yourself} in the core concepts (AtomSpace, patterns, frequency, and surprisingness).
  \item \textbf{Step through} the full mining pipeline--from abstracting link-nodes to scoring surprisingness--using diagrams and MeTTa code.
  \item \textbf{Run hands-on} MeTTa scripts to install, configure, and execute the Hyperon Pattern Miner on your own AtomSpace data.
  \item \textbf{Explore advanced use cases} and performance-tuning strategies so you can apply pattern mining to real-world datasets.
\end{enumerate}

By the end of this tutorial, you'll understand what the Hyperon Pattern Miner is, why it matters, and how it works--and be at least a little bit experienced with some hands-on examples.   You should then be prepared to work on some larger examples on your own if that's the direction your work or interest leads you!

\end{document}
