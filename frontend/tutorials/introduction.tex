\documentclass{article}

% ----------- core mathematics -----------
\usepackage{amsmath}   % align, split, cases, etc.
\usepackage{amssymb}   % \mathbb, \mathcal, \leqslant, \geqslant ...
\usepackage{amsfonts}  % blackboard bold, fraktur if desired
\usepackage{graphicx}  % for future figures, even if none are included yet
\usepackage{listings}  % for code examples
\usepackage{hyperref}  % clickable cross-refs; load last
\usepackage{mdframed}  % for boxed content

% ----------- tables & arrays ------------
\usepackage{array}     % extended column specifiers in tabular
\usepackage{booktabs}  % nicer horizontal rules (optional; you may keep \hline)
\usepackage{multirow}  % multi-row cells if you extend the tables later

% ----------- layout & floats ------------
\usepackage{geometry}  % easy margin control (defaults are fine; optional)
\usepackage{caption}   % better caption spacing for tables/figures

\title{What is MeTTa and why use it?}
\order{1}
\author{Mike Archbold}
\date{December 2025}

\begin{document}


\section{What is MeTTa and why use it?}

\subsection{It Might Not Be Clear What MeTTa Is}

Perhaps you tried a bit of MeTTa coding, or heard about MeTTa on social media, at a conference, or from a colleague, and want to explore. You heard it is an innovative AI language that would benefit your projects. 

You probably have some questions in mind such as:

\begin{itemize}
  \item What is the use of a symbolic AI language in an LLM age? Why learn it?
  \item It looks a bit like LISP. Is MeTTa a LISP variant?
  \item How do I install MeTTa on my machine?
  \item How can I understand the code? How many constructs do I really need for coding?
  \item What does "MeTTa" mean?
  \item Somebody said it was too slow. Is that still true? (No)
\end{itemize}

Well, if you have variations of these questions, you are on the right tutorial!


\subsection{It's Like a Fusion of SQL and Ordinary Code}

The single most defining characteristic of MeTTa is this: it insists on giving you all possible results. Whether you like it or not!

Suppose you are creating a package delivery routing application. Given a starting point and a destination, let's say ten routes exist, each with many twists and turns, so your code has lots of constraints. MeTTa outputs all ten complete routes in one run, at once. 

Now suppose you are creating a scheduling application. Given today's agenda, there are a ninety-nine possible schedules given available rooms, equipment, personnel, tasks, etc. Again, MeTTa outputs all ninety-nine schedules in a single result.

If this sounds to you a bit like an SQL "return all rows" matching request, you'd be on the right track. In essence, MeTTa is a fusion of "return all rows" SQL type calls and basically ordinary code. Given some specific inputs, code written in MeTTa by default will return all possible output combinations that result from executing all possible paths in your code applicable to the input. You get everything.

This might immediately raise the worrying prospect of having to deal with an avalanche of results. Well, don't worry, because there are ways of corralling MeTTa. Basically you only need about a dozen constructs to do everything you need in MeTTa.

\subsection{Corralling the Combinatorial Explosion}

Reality is incredibly complex. AI is a distinct discipline within computer science because worldly complex problems can't be handled by conventional programming in which all possible combinations are accounted for and pre-coded in advance. Techniques are developed to reach goals without requiring the specific pre-coding and foresight of all sequences of all possible combinations. AI evolved into a trick bag for handling such situations. AI, symbolic and neural, has to search for a path from start request to goal result without a predetermined route. 

Historically it has been difficult to write conventional symbolic programs to handle problems characterized by real world complexity. The strategy MeTTa employs to meet the challenge of corralling combinatorial explosions is to add a small set of programming principles and constructs to enable conventional seeming programs to manage and tame a massive number of combinations, possible paths and "all the results." (You can get similar results with languages such as Prolog, but Prolog is a very unusual language for beginning and potential users to learn.)

Thus creating conventional symbolic programs to handle huge combinations of possible cases is difficult or impossible. The fundamental strategy of MeTTa is to balance the use of more or less ordinary programs with a technique of managing the wild beast of combinatorial explosion. Using this technique: x y z.

So we use chess as example...

\section{How to Use the Tutorial}

This whole process is implemented in MeTTa, so if one runs it within a fast MeTTa interpretation or compilation framework, it should scale to huge numbers  of Atoms.  (Different Atoms may have different sizes, but very roughly, in a server with terabytes of RAM one may be able to host Atomspaces with 100B or more Atoms.)   It also exposes a clean API so you can integrate pattern mining directly into larger learning or reasoning pipelines.

\subsection{AtomSpace}

The \textbf{AtomSpace} is Hyperon's persistent metagraph store.  Every node and link you mine lives there.  In MeTTa you typically create or bind an AtomSpace via:

\begin{verbatim}
!(import! &self hyperon-miner:match:MinerMatch)
!(bind! &atom-space (new-space)) 
\end{verbatim}

All of the live examples on this tutorial operate within a single AtomSpace. As you run each code example, or "cell," you are continuously adding new information to this space, building upon the results from all the cells you have already run. The "Reset Atomspace" button wipes the whole atomspace and lets you start on a clean slate whilst the "reset" button on the cells (code snippets) themselves  provide a way to start over from that specific point whilst maintaing the state of the atom upto that particular snippet. The most common use case for these buttons is if you happen to be facing an import issue at some point you could reset the whole atomspace or reset the snippet that executes the importing tasks so that subsequent cells can get the correct imports they need. 

\subsection{Buttons}

\section{Tutorial Objectives}


\begin{enumerate}
  \item \textbf{Why} in the core concepts (AtomSpace, patterns, frequency, and surprisingness).
  \item \textbf{What} the full mining pipeline--from abstracting link-nodes to scoring surprisingness--using diagrams and MeTTa code.
  \item \textbf{How} MeTTa scripts to install, configure, and execute the Hyperon Pattern Miner on your own AtomSpace data.
\end{enumerate}

Conclude intro -- answer those first questions
\end{document}
