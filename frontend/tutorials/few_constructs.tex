\documentclass{article}

% ----------- core mathematics -----------
\usepackage{amsmath}   % align, split, cases, etc.
\usepackage{amssymb}   % \mathbb, \mathcal, \leqslant, \geqslant ...
\usepackage{amsfonts}  % blackboard bold, fraktur if desired
\usepackage{graphicx}  % for future figures, even if none are included yet
\usepackage{listings}  % for code examples
\usepackage{hyperref}  % clickable cross-refs; load last
\usepackage{mdframed}  % for boxed content

% ----------- tables & arrays ------------
\usepackage{array}     % extended column specifiers in tabular
\usepackage{booktabs}  % nicer horizontal rules (optional; you may keep \hline)
\usepackage{multirow}  % multi-row cells if you extend the tables later

% ----------- layout & floats ------------
\usepackage{geometry}  % easy margin control (defaults are fine; optional)
\usepackage{caption}   % better caption spacing for tables/figures

\title{You Only Need These Few Constructs}
\order{4}

\begin{document}

\section{You Only Need These Few Constructs}

\subsection{Some Good News}

First some good news! Solid and potent MeTTa code can be built with only about a dozen fairly simple programming constructs. The possible downside though is that MeTTa, while a unique language, does look somewhat like LISP with nested, balanced parenthesis to mind. However, a bit of practice and an IDE that tracks parenthesis nesting with colors works wonders.

Below is a crash course covering a few code constructs to add and manipulate atoms, assign variables, define rewrite rules, handle conditional execution, run a sequence of statements, loop, and manage the combinatorial explosion with the superpose, match, and collapse functions. 

We'll use these to create the chess game in the next section.

Atomspace, where all MeTTa code and data reside, can be subdivided into sub-spaces. The default sub-space is known as "&self". For this tutorial we'll just use "&self" although it is possible to create arbitrary spaces (eg., "&myatoms"). 

After you run the examples in this tutorial you can check your atomspace by clicking the button to display atomspace on top of each tutorial page. To tidy things up as you work through the examples click the button to reset atomspace. Refreshing your browser page will reset the examples and clear atomspace. Code boxes can also be reset individually and those with a challenge question will have a "Cheat" button if you just feel like displaying the answer.

\subsection{Add and Manipulate Atoms}

The quickest way to add atoms to atomspace is by declaration in your program. The following example will add "(my declared atom)" to the "&self" sub-space. Note that if you declare atoms using this simple approach such atoms are placed in the "&self" sub-space only. When using this style to add atoms, simple declaration is enough -- there is no need to prefix the expression with "!".

\begin{verbatim}
(my declared atom)
\end{verbatim}

\subsubsection{add-atom}

Another way of adding atoms is by using "add-atom" as in the following example. When you use "add-atom" it is necessary to specify the sub-space within atomspace ("&self" for the tutorial). In this example we need to prefix the statement with "!" to force MeTTa to execute the expression, to actually add "(my second declared atom)" to atomspace. Try running the code example both with and without the "!" prefix. By displaying and resetting atomspace after each run you can observe the difference. As a general rule, prefixing with "!" will trigger immediate execution of the expression. Omission of the "!" prefix will add the entire expression to atomspace without execution. This is a subtle but important difference but easy to see by checking atomspace.


\begin{verbatim}
!(add-atom &self (my second declared atom))
;; cheat: (add-atom &self (my second declared atom))
\end{verbatim}

\subsubsection{remove-atom}

The basic format for removing atoms from atomspace is identical to "add-atom" except we use "remove-atom". The following example first adds an atom. After you run the following code, check to see if "(my third atom)" is in atomspace. Then simply change "add-atom" to "remove-atom" in the code block (or click "Cheat") to delete "(my third atom)" from atomspace.  Run the changed code and then click to display atomspace. The "(my third atom)" atom will be removed. 

\begin{verbatim}
!(add-atom &self (my third atom))
;; cheat: !(remove-atom &self (my third atom))
\end{verbatim}

\subsection{Variables}


\subsubsection{let and let*}

All variables in MeTTa are prefixed with the dollar sign. The "let" construct is useful for assigning values to variables. The first argument to "let" is the variable to be assigned a value, and the second argument its value. Lastly the third argument can make use of the variable. In the example below, the value of "$var1" is returned by the "let" statement.
 
\begin{verbatim}
!(let $var1 Lighthouse $var1)
\end{verbatim}

Expressions in the second and third arguments of "let" are evaluated, or "reduced," if MeTTa can find a way to further execute. In the above example the symbol "Lighthouse" was returned from the "let" construct since there was nothing left to evaluate or execute with just "Lighthouse" assigned to our variable. 

In the example below the second argument's expression simply adds 1 and 1. The result 2 is assigned to "$var1", and then the third argument uses the variable (now with value 2) inside a small list atom. The value assigned to the variable is available to the third argument. The third argument is the result of the "let" construct.

\begin{verbatim}
!(let $var1 (+ 1 1) (result $var1))
\end{verbatim}

Challenge: modify the below code example so that "(result $var1)" is added to atomspace.

\begin{verbatim}
!(let $var1 (+ 1 1) ???)
;; cheat: !(let $var1 (+ 1 1) (add-atom &self (result $var1)))
\end{verbatim}

A fancier variation of the "let" construct is "let*". The first argument to "let*" is a list of variables and their assignments. The second argument allows you to compute with any of the variables created in the first argument. In the example below two variables are assigned values in the first argument list and then added together in the second argument to "let*". The second argument is the result returned by the "let*" construct.

\begin{verbatim}
!(let*
   ( ($var1  (+ 1 1))  ($var2  (+ 1 $var1) )  )
   (+ $var1 $var2)
   )  
\end{verbatim}

Challenge: create another variable "$var3" with a value of 2. Return the result of var2 less var3.

\begin{verbatim}
!(let*
   ( ($var1  (+ 1 1))  ($var2  (+ 1 $var1) ) ???? )
   (- $var2 ??? )
   )  
;;cheat: !(let*
;;cheat:      ( ($var1  (+ 1 1))  ($var2  (+ 1 $var1) )  ($var3 2))
;;cheat:      (- $var2 $var3)
;;cheat:    )  
\end{verbatim}



\end{document}
