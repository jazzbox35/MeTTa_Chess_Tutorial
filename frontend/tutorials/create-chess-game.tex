\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{MeTTa Components for a Simple Chess Game}
\order{3}

\begin{document}


\section{How to Create a Simple Chess Game}

Now armed with a few MeTTa constructs, we'll examine practical MeTTa software development. 

\subsection{Reset Atomspace to Default Greedy Chess Program}

For this tutorial section we will be using the default MeTTa greedy chess program. To use the default chess program \textbf{please click "Reset Atomspace" if enabled (not greyed-out) and then click "Play Chess".} If "Reset Atomspace" is greyed-out, just click "Play Chess". If you are taken to the chessboard tab, return to this tab. 

In general, if you see unexpected results, simply clicking "Reset Atomspace" and then "Play Chess" will reset atomspace to the default program.

\subsection{Backend MeTTa server}

We will be using a backend MeTTa server running in the cloud. Gameplay is handled through your browser which sends only two commands to the backend MeTTa server: M and S which handle piece (M)oving and (S)tart/reset respectively. These commands are defined in the "Command handler functions for gameplay" section below.

\subsection{Program Components}

Note that we won't be dynamically redefining functions, although it's possible in MeTTa. For our chess program, the following categories are defined:

\begin{itemize}
  \item \texttt{Utility functions}
  \item \texttt{Constants for use throughout the program's run}
  \item \texttt{Chess related functions}
  \item \texttt{Command handler functions for gameplay}
\end{itemize}

The chess program is stored in atomspace using your browser (in a format maintained by the MeTTa server). We will be covering only the most salient functions in the chess program herein. However, in addition to displaying atomspace by clicking the button above, you can download the full source code by clicking on the "Your Turn to Improve the Game" section and look for the download link. 

\subsubsection{Utility Functions}

First we need to define a few general functions to be used by the whole program.

Our first couple of functions are standard LISP-ish looking tail recursion functions. In MeTTa \textbf{car-atom} and \textbf{cdr-atom} (as well as \textbf{cons-atom}) are effectively the same as LISP but with -"atom" appended. If you need a refresher or crash course in these constructs an LLM would help. \textbf{car-atom} gives you the first symbol in a list while \textbf{cdr-atom} the rest of the list, still in parenthesis. The main trick is that you code the end boundary case and the general recursive
case for items remaining in the list. Fortunately, you do less tail recursion searching in MeTTa than LISP but
it is still a handy way of looping through a list.

The chess program uses the following format for board squares:

\textbf{(x y color piece)}

If length is 4, the square is occupied. If length is 2, unoccupied. x and y are standard Cartesian coordinates.
Piece color values are either s for silver (human) or g for gold (AI). Piece types are r, n, b, q, k, p for 
rook, knight, bishop, queen, king, and pawn respectively.

\textbf{The nth function is used constantly in the program to extract piece details.}

\begin{verbatim}
; HIDE-RUN    
;***************************************************************
; Function:     nth
; Description:  Returns the N-th element from a list (1-based index).
;
; Input:        $n     - The position (1-based) of the element to return.
;               $list  - A list of elements (e.g., (a b c d)).
;
; Output:       The atom at position $n in the list. Returns the first element if n = 1.
;***************************************************************
(= (nth $n $list) 
    (if (== $n 1)
        (car-atom $list)
        (nth (- $n 1) (cdr-atom $list)))) ; Recursion: move to the next element (cdr-atom) and decrease n.
\end{verbatim}

\begin{verbatim}
; reset chess game to initial state
!(S)

; find x axis value for this silver pawn located in square (2, 2)
!(nth 1 (2 2 s p))   
\end{verbatim}

\textbf{Function to check for a symbol in a list and a function to add numbers.}

\begin{verbatim}
; HIDE-RUN
;***************************************************************
; Function:     contains_symbol
; Description:  Checks whether a given symbol exists in a list.
;
; Input:        $list - A list of atoms (e.g., (a b c d))
;               $sym  - A symbol to search for in the list
;
; Output:       True if $sym is found in $list; otherwise False
;***************************************************************
(= (contains_symbol $list $sym) 
    (if (== $list ())
        False
        (if (== (car-atom $list) $sym)
            True
            (contains_symbol (cdr-atom $list) $sym))))

;***************************************************************
; Function:     addit_list
; Description:  Computes the sum of a list of integers.
;
; Input:        $integer_list - A list of integers (e.g., (1 2 3 4))
;
; Output:       The total sum of all integers in the list (e.g., 10)
;***************************************************************
(= (addit_list $integer_list)
    (if (== $integer_list ())
        0
        (+ (car-atom $integer_list) (addit_list (cdr-atom $integer_list)))))
\end{verbatim}



\begin{verbatim}
!(S)

; see if there is a gold piece in board square (1 8) 
!(contains_symbol (1 8) g)

; add up a list of numbers
!(addit_list (4 7 1 20))
\end{verbatim}

Our next function \textbf{int_to_char} is a simple case statement to determine the x-axis letter that 
corresponds to the numeric Cartesian x value. The program returns conventional letters for the chess x-axis.

\begin{verbatim}
; HIDE-RUN    
;***************************************************************
; Function:     int_to_char
; Description:  Converts an integer 1..8 to the corresponding incremental letter.
;
; Input:        $int - Integer in range 1 to 8
;
; Output:       Corresponding file letter "a".."h", or "?" if invalid
;***************************************************************
(= (int_to_char $int)
    (case $int
        (
        (1 A)
        (2 B)
        (3 C)
        (4 D)
        (5 E)
        (6 F)
        (7 G)
        (8 H)
        ($_ ?) ; fallback for invalid input
        )))

\end{verbatim}

\begin{verbatim}
; initialize program
!(S)

;example int_to_char call        
!(int_to_char 5)
\end{verbatim}

\subsubsection{Declaring Constants and Initialization for the Run}

An easy way to define constants is just by coding them. These can be looked up in the \textbf{&self} 
space using \textbf{match}.

\begin{verbatim}
;HIDE-RUN
;*******************************************************
; Constants 
;*******************************************************

(highestrank k) 
(highrank q) 
(medrank r) 
(medrank b) 
(medrank n) 
(lowrank p) 

(rank k) 
(rank q) 
(rank r) 
(rank b) 
(rank n) 
(rank p) 

\end{verbatim}

\begin{verbatim}
!(S) ;reset for demo

;example to return all ranks in a list. You get all ranks because MeTTa insists on giving all the results!
!(collapse (match &self (rank $rank) $rank))
\end{verbatim}

The following expression adds an atom for game state. It's not a constant since we will be changing it later
by removing and adding an atom of the form "(game-state -value-)".

\begin{verbatim}
; HIDE-RUN
;*******************************************************
; Declare initializing game state
;*******************************************************

(game-state initializing)

\end{verbatim}


\subsubsection{Chess Related Functions}

The program persists two major data structures between moves. One is the chessboard state, the second game state:

1) \textbf{(board-state (  (1 1 s r) (1 2 s n).... (4 4).... (1 8 g r)... ))} with 64 sublists

2) \textbf{(game-state -value-)}

The "board-state" list is not used as the data structure for searching. Instead, when the AI is experimenting with possible next moves, small standalone atoms in atomspace are created for each square of this form:

\textbf{(square x y color rank) and (square x y)} to denote both occupied and unoccupied squares.

The reason the longer "board-state" list of 64 elements representing all squares on the chessboard is \textbf{not} used for deep searches is because \textbf{METTA IS FASTER LOOKING UP INDIVIDUAL ATOMS THAN CHUGGING SEQUENTIALLY THROUGH LISTS.} A defining feature of MeTTa is random access in atomspace, not LISP-ish tail recursion search.

The following functions are used for the input of the 64-element board list and output of temporary 
atomic "square" (as above) atoms for all chess pieces. The deep searching in the program uses these 
atomic "square" atoms for speed. There are also functions for small atom lists used for game state handling and scoring moves.

\textbf{Example to add individual square atoms to atomspace}

\begin{verbatim}
; HIDE-RUN
;***************************************************************
; Function:     add-pieces
; Description:  Converts a board representation into atomspace facts.
;               Each square from the board list becomes a `(square ...)` atom.
;
; Input:        $board - A list of square definitions:
;                        Each square is either (x y) for empty or (x y color piece) if occupied.
;
; Output:       Adds each square to the atomspace as a `(square ...)` atom.
;               Returns True after processing the entire board.
;***************************************************************
(= (add-pieces $board)
  (if (== $board ())
      True
      (let* (
            ($next-square (car-atom $board))
            ($next-square-atom (cons-atom square $next-square))
            ($_ (add-atom &self $next-square-atom))
            )
      (add-pieces (cdr-atom $board)))))

\end{verbatim}


\begin{verbatim}
!(S) ;reset for demo

; Here we call add-pieces to create individual square atoms for each piece. Display atomspace after running this command and you should see individual atoms of the form (square x y ...)
!(add-pieces ((1 8 g r) (2 8 g n) (3 8 g b) (4 8 g q) (5 8 g k) (6 8 g b) (7 8 g n) (8 8 g r) 
                        (1 7 g p) (2 7 g p) (3 7 g p) (4 7 g p) (5 7 g p) (6 7 g p) (7 7 g p) (8 7 g p) 
                        (1 6) (2 6) (3 6) (4 6) (5 6) (6 6) (7 6) (8 6) 
                        (1 5) (2 5) (3 5) (4 5) (5 5) (6 5) (7 5) (8 5) 
                        (1 4) (2 4) (3 4) (4 4) (5 4) (6 4) (7 4) (8 4) 
                        (1 3) (2 3) (3 3) (4 3) (5 3) (6 3) (7 3) (8 3) 
                        (1 2 s p) (2 2 s p) (3 2 s p) (4 2 s p) (5 2 s p) (6 2 s p) (7 2 s p) (8 2 s p) 
                        (1 1 s r) (2 1 s n) (3 1 s b) (4 1 s q) (5 1 s k) (6 1 s b) (7 1 s n) (8 1 s r))   
  )
\end{verbatim}

\textbf{Function to reset the small 'square' atoms and refresh 'square' atoms with input-supplied chessboard}

\begin{verbatim}
; HIDE-RUN

;***************************************************************
; Function:     reset-pieces
; Description:  Clears existing board state from atomspace and
;               re-injects the current board list as square atoms.
;
; Input:        $board - The current board, as a list of square terms:
;                        Each term is (x y) for empty, or (x y color rank) for occupied.
;
; Output:       Atomspace is updated with the board's square atoms.
;***************************************************************
(= (reset-pieces $board)
    (progn
      ; remove prior occupied square atoms from atomspace
      (remove-atom &self (square $x $y $s $p))  
      ; remove empty squares too
      (remove-atom &self (square $x $y))  
      ; now add the present board's squares to atomspace.
      (add-pieces $board)))

\end{verbatim}

\textbf{Function to reset the small 'square' atoms and refresh 'square' atoms with a mocked up current chessboard state; note pawn defined with atom (square 4 4 s p).}  One nice thing about processing small atoms using the match
construct is that there is a lot less LISP-ish tail recursion that is invariably harder to read and slower too.

\begin{verbatim}
; refresh the 'square' atoms using the input chessboard. Check atomspace to verify a pawn is in (4 4)

!(collapse (reset-pieces
            ((1 8 g r) (2 8 g n) (3 8 g b) (4 8 g q) (5 8 g k) (6 8 g b) (7 8 g n) (8 8 g r) 
                        (1 7 g p) (2 7 g p) (3 7 g p) (4 7 g p) (5 7 g p) (6 7 g p) (7 7 g p) (8 7 g p) 
                        (1 6) (2 6) (3 6) (4 6) (5 6) (6 6) (7 6) (8 6) 
                        (1 5) (2 5) (3 5) (4 5) (5 5) (6 5) (7 5) (8 5) 
                        (1 4) (2 4) (3 4) (4 4 s p) (5 4) (6 4) (7 4) (8 4) 
                        (1 3) (2 3) (3 3) (4 3) (5 3) (6 3) (7 3) (8 3) 
                        (1 2 s p) (2 2 s p) (3 2 s p) (4 2) (5 2 s p) (6 2 s p) (7 2 s p) (8 2 s p) 
                        (1 1 s r) (2 1 s n) (3 1 s b) (4 1 s q) (5 1 s k) (6 1 s b) (7 1 s n) (8 1 s r))))

\end{verbatim}

\textbf{Functions to change game state}

\begin{verbatim}
; HIDE-RUN

;***************************************************************
; Function:     delete-prior-game-states
; Description:  Removes any existing `(game-state ...)` atoms from atomspace.
;               Used before setting a new game state.
;
; Input:        None
;
; Output:       Atomspace no longer contains any `game-state` atoms.
;***************************************************************
(= (delete-prior-game-states)
    (collapse (match &self (game-state $prior-state) (remove-atom &self (game-state $prior-state))))
)

;***************************************************************
; Function:     change-game-state
; Description:  Resets the current game state and sets a new one.
;
; Input:        $new-state - A symbol representing the new game state,
;                            e.g., `started`, `checkmate`, `restarted`, etc.
;
; Output:       Replaces any existing `game-state` atom with the new one.
;***************************************************************
(= (change-game-state $new-state)
  (progn
    (delete-prior-game-states) 
    (add-atom &self (game-state $new-state))))

\end{verbatim}

\begin{verbatim}

!(S) ;reset for demo

; Note that delete-prior-game-states uses a 'collapse' to ensure ALL prior game state atoms are removed. After running this atomspace should show (game-state checkmate).

!(change-game-state checkmate)

\end{verbatim}

In the following function, (lots_of_pawns_in_home_row), there is a \textbf{match} construct used
inside the second argument to find all AI gold pawns (designated with a 'g') in row 7, the AI home row for pawns. Notice that our
friend the \textbf{collapse} encircles the match statement. The effect of this construct is "give me all these pawns and don't return here for more execution later." The result of the second argument, a list of 'square' atoms of the form (square x 7 g p) is assigned to let's variable. Then \textbf{size-atom} returns the length of the list and a boolean check returns true or false. Again, we don't have to loop through a list searching -- we just use the formula of a \textbf{match} working on atomspace followed by a \textbf{collapse.} 

\begin{verbatim}
; HIDE-RUN
;***************************************************************
; Function:     lots_of_pawns_in_home_row
; Description:  Checks whether more than x AI (gold) pawns are still on row 7.
;               Used to influence early-game move strategy.
;
; Input:        None
;
; Output:       True if more than x (see below) pawns remain on row 7 (initial position);
;               otherwise False.
;***************************************************************
(= (lots_of_pawns_in_home_row)
   (let $pawns_at_home (collapse (match &self (square $x 7 g p) (square $x $y $s $p)))
        (if (> (size-atom $pawns_at_home) 6) ; <-- set here
          True
          False)))
\end{verbatim}

\begin{verbatim}

; We intialize the program for starting board state. Then a call to search the 'square' atoms will reveal more than 6 in the AI's starting row of pawns. If you take the "g" and "p" out of a few of the pawns designated in row 7 the function will return false.

!(S) ;reset for demo

!(reset-pieces ((1 8 g r) (2 8 g n) (3 8 g b) (4 8 g q) (5 8 g k) (6 8 g b) (7 8 g n) (8 8 g r) 
                        (1 7 g p) (2 7 g p) (3 7 g p) (4 7 g p) (5 7 g p) (6 7 g p) (7 7 g p) (8 7 g p) 
                        (1 6) (2 6) (3 6) (4 6) (5 6) (6 6) (7 6) (8 6) 
                        (1 5) (2 5) (3 5) (4 5) (5 5) (6 5) (7 5) (8 5) 
                        (1 4) (2 4) (3 4) (4 4) (5 4) (6 4) (7 4) (8 4) 
                        (1 3) (2 3) (3 3) (4 3) (5 3) (6 3) (7 3) (8 3) 
                        (1 2 s p) (2 2 s p) (3 2 s p) (4 2 s p) (5 2 s p) (6 2 s p) (7 2 s p) (8 2 s p) 
                        (1 1 s r) (2 1 s n) (3 1 s b) (4 1 s q) (5 1 s k) (6 1 s b) (7 1 s n) (8 1 s r)))

!(lots_of_pawns_in_home_row)

\end{verbatim}

The following function \textbf{xy_box} inputs the piece color (gold for AI, silver for player) and rank, and outputs coordinates for the location of all pieces that match. The first version is really all you need in MeTTa. The second version is what happens if you decide to loop through lists. 
Invoke \textbf{xy_box} inside a collapse. If you see the collapse construct just think to yourself "give me the results and don't come back!" 

\begin{verbatim}
; HIDE-RUN
;***********************************************************************
; Function:    xy_box
; Description: Find the coordinates of a piece on the board.
; Input:       A piece descriptor in the form: (color rank)
; Output:      Coordinates (x y) where the piece is located
;***********************************************************************
(= (xy_box ($PieceColor $PieceRank))
       (match &self (square $x $y $PieceColor $PieceRank) ($x $y))) 

;***********************************************************************
; obsolete comparison versions...
;
; (xy_box_recursive)
;     1. Searches the board for a square containing the specified piece.
;     2. Returns the x/y coordinates of the square if a match is found.
;
;***********************************************************************
(= (xy_box_recursive ($PieceColor $PieceRank) $Board)
  (let*
    (
    ; assign variables for the next piece
    ($next_square (car-atom $Board)  )
    ($next_x (nth 1 $next_square) )
    ($next_y (nth 2 $next_square) )
    )
    ; then examine next square
    (if (== (size-atom $next_square) 2) 
      ; empty square, skip
      (xy_box_recursive ($PieceColor $PieceRank) (cdr-atom $Board))
      ; else check this piece
      (let* (
            ($next_color (nth 3 $next_square) )
            ($next_rank  (nth 4 $next_square) )
            )
            (if
              (and (== $next_color $PieceColor)
                   (== $next_rank $PieceRank))
                ; return x and y of the found piece
                ($next_x $next_y)
                ; else keep checking the board
                (xy_box_recursive ($PieceColor $PieceRank) (cdr-atom $Board)))))))
\end{verbatim}


\begin{verbatim}
!(S) ;reset for demo

!(reset-pieces ((1 8 g r) (2 8 g n) (3 8 g b) (4 8 g q) (5 8 g k) (6 8 g b) (7 8 g n) (8 8 g r) 
                        (1 7 g p) (2 7 g p) (3 7 g p) (4 7 g p) (5 7 g p) (6 7 g p) (7 7 g p) (8 7 g p) 
                        (1 6) (2 6) (3 6) (4 6) (5 6) (6 6) (7 6) (8 6) 
                        (1 5) (2 5) (3 5) (4 5) (5 5) (6 5) (7 5) (8 5) 
                        (1 4) (2 4) (3 4) (4 4) (5 4) (6 4) (7 4) (8 4) 
                        (1 3) (2 3) (3 3) (4 3) (5 3) (6 3) (7 3) (8 3) 
                        (1 2 s p) (2 2 s p) (3 2 s p) (4 2 s p) (5 2 s p) (6 2 s p) (7 2 s p) (8 2 s p) 
                        (1 1 s r) (2 1 s n) (3 1 s b) (4 1 s q) (5 1 s k) (6 1 s b) (7 1 s n) (8 1 s r)))

!(collapse (xy_box (g b)))


\end{verbatim}
\subsubsection{Putting It All Together}



\begin{verbatim}
; ok
\end{verbatim}

Summary


\end{document}
