\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{MeTTa Components for a Simple Chess Game}
\order{3}

\begin{document}


\section{How to Create a Simple Chess Game}

Now armed with a few MeTTa constructs, we'll jump into practical MeTTa software development. 

We will be using a backend MeTTa server running in the cloud. Gameplay is handled through your browser which sends only two commands to the backend MeTTa server: M and S which handle piece (M)oving and (S)tart/reset respectively. These commands are defined in the "Command handler functions for gameplay" section below.

Note that we won't be dynamically redefining functions, although it's possible in MeTTa. To create our chess program, we need to define the following:

\begin{itemize}
  \item \texttt{Utility functions}
  \item \texttt{Constants for use throughout the program's run}
  \item \texttt{Chess related functions}
  \item \texttt{Command handler functions for gameplay}
\end{itemize}

The chess program is stored in atomspace using your browser. 

If at any time you wish to reset atomspace to the default MeTTa chess program just click "Reset Atomspace" and then click "Play Chess". If "Reset Atomspace" is greyed-out, there is no need to click.

In general, if you see unexpected results or an error, try clicking "Reset Atomspace" and proceeding with examples. 

Please click "Reset Atomspace"  (if enabled) now to start with a clean slate.

\subsection{Utility Functions}

First we need to define a few general functions to be used by the whole program.

Our first couple of functions are standard LISP-ish looking tail recursion functions. In MeTTa \textbf{car-atom} and \textbf{cdr-atom} (as well as \textbf{cons-atom}) are effectively the same as LISP but with -"atom" appended. If you need a refresher or crash course in these constructs an LLM would help. \textbf{car-atom} gives you the first symbol in a list while \textbf{cdr-atom} the rest of the list, still in parenthesis. The main trick is that you code the end boundary case and the general recursive
case for items remaining in the list. Fortunately, you do less tail recursion searching in MeTTa than LISP but
it is still a handy way of looping through a list.

The chess program uses the following format for board squares:

\textbf{(x y color piece)}

If length is 4, the square is occupied. If length is 2, unoccupied. x and y are standard Cartesian coordinates.
Piece color values are either s for silver (human) or g for gold (AI). Piece types are r, n, b, q, k, p for 
rook, knight, bishop, queen, king, and pawn respectively.

The \textbf{nth} function is used constantly in the program to extract piece details. 

\begin{verbatim}
; HIDE-RUN    
;***************************************************************
; Function:     nth
; Description:  Returns the N-th element from a list (1-based index).
;
; Input:        $n     - The position (1-based) of the element to return.
;               $list  - A list of elements (e.g., (a b c d)).
;
; Output:       The atom at position $n in the list. Returns the first element if n = 1.
;***************************************************************
(= (nth $n $list) 
    (if (== $n 1)
        (car-atom $list)
        (nth (- $n 1) (cdr-atom $list)))) ; Recursion: move to the next element (cdr-atom) and decrease n.

;***************************************************************
; Function:     contains_symbol
; Description:  Checks whether a given symbol exists in a list.
;
; Input:        $list - A list of atoms (e.g., (a b c d))
;               $sym  - A symbol to search for in the list
;
; Output:       True if $sym is found in $list; otherwise False
;***************************************************************
(= (contains_symbol $list $sym) 
    (if (== $list ())
        False
        (if (== (car-atom $list) $sym)
            True
            (contains_symbol (cdr-atom $list) $sym))))

;***************************************************************
; Function:     addit_list
; Description:  Computes the sum of a list of integers.
;
; Input:        $integer_list - A list of integers (e.g., (1 2 3 4))
;
; Output:       The total sum of all integers in the list (e.g., 10)
;***************************************************************
(= (addit_list $integer_list)
    (if (== $integer_list ())
        0
        (+ (car-atom $integer_list) (addit_list (cdr-atom $integer_list)))))

\end{verbatim}

\begin{verbatim}
; reset chess game to initial state
!(S)

; find x axis value for this silver pawn located in square (2, 2)
!(nth 1 (2 2 s p))   

; see if there is a gold piece in board square (1 8) 
!(contains_symbol (1 8) g)

; add up a list of numbers
!(addit_list (4 7 1 20))
\end{verbatim}

Just a reminder that if you seem to be getting far too many results, especially of the same value, it is because whenever you click "Run" to execute the code box MeTTa will add the functions inside the box to
atomspace. Two versions of \textbf{nth} will give you multiple results. All you need to do is click "Reset Atomspace" regularly to avoid this problem. 

Our next function \textbf{int_to_char} is a simple case statement to determine the x-axis letter that 
corresponds to the numeric Cartesian x value. The program returns conventional letters for the chess x-axis.

\begin{verbatim}
   
;***************************************************************
; Function:     int_to_char
; Description:  Converts an integer 1..8 to the corresponding incremental letter.
;
; Input:        $int - Integer in range 1 to 8
;
; Output:       Corresponding file letter "a".."h", or "?" if invalid
;***************************************************************
(= (int_to_char $int)
    (case $int
        (
        (1 A)
        (2 B)
        (3 C)
        (4 D)
        (5 E)
        (6 F)
        (7 G)
        (8 H)
        ($_ ?) ; fallback for invalid input
        )))

;example look up        
!(int_to_char 5)
\end{verbatim}

\subsection{Declaring Constants and Initialization for the Run}

An easy way to define constants is just by coding them. These can be looked up in the \textbf{&self} 
space using \textbf{match}.

\begin{verbatim}
;*******************************************************
; Constants 
;*******************************************************

(highestrank k) 
(highrank q) 
(medrank r) 
(medrank b) 
(medrank n) 
(lowrank p) 

(rank k) 
(rank q) 
(rank r) 
(rank b) 
(rank n) 
(rank p) 

;example to return all ranks in a list. You get all ranks because MeTTa insists on giving all the results!
!(collapse (match &self (rank $rank) $rank))
\end{verbatim}

The following expression adds an atom for game state. It's not a constant since we will be changing it later
by removing and adding an atom of the form "(game-state -value-)".

\begin{verbatim}

;*******************************************************
; Declare initializing game state
;*******************************************************

(game-state initializing)

; in this example query, we look up game-state, remove it, then add a new game state.
; progn works nicely for running a sequence of expressions.
!(match &self (game-state $state) 
    (progn 
        (remove-atom &self (game-state $state))
        (add-atom &self (game-state started))))

\end{verbatim}

\subsection{Chess Related Functions}

Now would be a good time to click "Reset Atomspace".

The program persists two major data structures between moves. One is the chessboard, the second game state:

1) \textbf{(board-state (  (1 1 s r) (1 2 s n).... (4 4).... (1 8 g r)... ))} with 64 sublists

2) \textbf{(game-state -value-)}

The "board-state" list is not used as the data structure for searching: when the AI is experimenting with possible next moves, small standalone atoms in atomspace are created for each square of this form:

\textbf{(square x y color rank) and (square x y)} to denote both occupied and unoccupied squares.

The reason the longer "board-state" list of 64 elements representing all squares on the chessboard is not used for deep searches is because \textbf{METTA IS MUCH FASTER LOOKING UP INDIVIDUAL ATOMS THAN CHUGGING SEQUENTIALLY THROUGH LISTS.} A defining feature of MeTTa is random access in atomspace, not LISP-ish tail recursion search.

The following functions are used for the input of the 64-element board list and output of temporary 
atomic "square" (as above) atoms for all chess pieces. The deep searching in the program uses these 
atomic "square" atoms for speed.

\begin{verbatim}

;***************************************************************
; Function:     add-pieces
; Description:  Converts a board representation into atomspace facts.
;               Each square from the board list becomes a `(square ...)` atom.
;
; Input:        $board - A list of square definitions:
;                        Each square is either (x y) for empty or (x y color piece) if occupied.
;
; Output:       Adds each square to the atomspace as a `(square ...)` atom.
;               Returns True after processing the entire board.
;***************************************************************
(= (add-pieces $board)
  (if (== $board ())
      True
      (let* (
            ($next-square (car-atom $board))
            ($next-square-atom (cons-atom square $next-square))
            ($_ (add-atom &self $next-square-atom))
            )
      (add-pieces (cdr-atom $board)))))

;***************************************************************
; Function:     reset-pieces
; Description:  Clears existing board state from atomspace and
;               re-injects the current board list as square atoms.
;
; Input:        $board - The current board, as a list of square terms:
;                        Each term is (x y) for empty, or (x y color rank) for occupied.
;
; Output:       Atomspace is updated with the board's square atoms.
;***************************************************************
(= (reset-pieces $board)
    (progn
      ; remove prior occupied square atoms from atomspace
      (remove-atom &self (square $x $y $s $p))  
      ; remove empty squares too
      (remove-atom &self (square $x $y))  
      ; now add the present board's squares to atomspace.
      (add-pieces $board)))

;***************************************************************
; Function:     delete-pieces
; Description:  Removes all square-related atoms from the atomspace.
;
; Input:        None
;
; Output:       Atomspace is cleared of all `(square ...)` atoms,
;               both occupied and empty.
;***************************************************************
(= (delete-pieces)
    (progn
      ; remove prior occupied square atoms from atomspace
      (remove-atom &self (square $x $y $s $p))  
      ; remove empty squares too
      (remove-atom &self (square $x $y))  
      ))

;***************************************************************
; Function:     delete-temporary-atoms
; Description:  Removes all temporary `score` atoms used during AI move evaluation.
;
; Input:        None
;
; Output:       Cleans the atomspace of all `(score ...)` atoms,
;               which represent scores of hypothetical evaluations of AI moves.
;***************************************************************
(= (delete-temporary-atoms)
  (match &self
    (score $X1 $Y1 $color $rank $X2 $Y2 $Opponent_hypothetical_score $AI_hypothetical_score)
        ;($X1 $Y1 $color $rank $X2 $Y2 $Opponent_hypothetical_score $AI_hypothetical_score)))
    (remove-atom &self 
    (score $X1 $Y1 $color $rank $X2 $Y2 $Opponent_hypothetical_score $AI_hypothetical_score))))

;***************************************************************
; Function:     delete-prior-game-states
; Description:  Removes any existing `(game-state ...)` atoms from atomspace.
;               Used before setting a new game state.
;
; Input:        None
;
; Output:       Atomspace no longer contains any `game-state` atoms.
;***************************************************************
(= (delete-prior-game-states)
    (collapse (match &self (game-state $prior-state) (remove-atom &self (game-state $prior-state))))
)

;***************************************************************
; Function:     change-game-state
; Description:  Resets the current game state and sets a new one.
;
; Input:        $new-state - A symbol representing the new game state,
;                            e.g., `started`, `checkmate`, `restarted`, etc.
;
; Output:       Replaces any existing `game-state` atom with the new one.
;***************************************************************
(= (change-game-state $new-state)
  (progn
    (delete-prior-game-states) 
    (add-atom &self (game-state $new-state))))



\end{verbatim}

Example to add individual square atoms to atomspace 

\begin{verbatim}

; Here we call add-pieces to create individual square atoms for each piece. Display atomspace after running.
!(add-pieces ((1 8 g r) (2 8 g n) (3 8 g b) (4 8 g q) (5 8 g k) (6 8 g b) (7 8 g n) (8 8 g r) 
                        (1 7 g p) (2 7 g p) (3 7 g p) (4 7 g p) (5 7 g p) (6 7 g p) (7 7 g p) (8 7 g p) 
                        (1 6) (2 6) (3 6) (4 6) (5 6) (6 6) (7 6) (8 6) 
                        (1 5) (2 5) (3 5) (4 5) (5 5) (6 5) (7 5) (8 5) 
                        (1 4) (2 4) (3 4) (4 4) (5 4) (6 4) (7 4) (8 4) 
                        (1 3) (2 3) (3 3) (4 3) (5 3) (6 3) (7 3) (8 3) 
                        (1 2 s p) (2 2 s p) (3 2 s p) (4 2 s p) (5 2 s p) (6 2 s p) (7 2 s p) (8 2 s p) 
                        (1 1 s r) (2 1 s n) (3 1 s b) (4 1 s q) (5 1 s k) (6 1 s b) (7 1 s n) (8 1 s r))   
  )
\end{verbatim}

  \subsection{Putting It All Together}



\begin{verbatim}
(end)
\end{verbatim}

Summary


\end{document}
