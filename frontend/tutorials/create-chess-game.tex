\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\title{MeTTa Components for a Simple Chess Game}
\order{3}

\begin{document}


\section{How to Create a Simple Chess Game}

Now armed with a few MeTTa constructs, we'll jump into practical MeTTa software development. 

We will be using a backend MeTTa server running in the cloud. Gameplay is handled through your browser which sends only two commands to the backend MeTTa server: M and S which handle piece (M)oving and (S)tart/reset respectively. These commands are defined in the "Command handler functions for gameplay" section below.

Note that we won't be dynamically redefining functions, although it's possible in MeTTa. To create our chess program, we need to define the following:

\begin{itemize}
  \item \texttt{Utility functions}
  \item \texttt{Constants for use throughout the program's run}
  \item \texttt{Chess functions}
  \item \texttt{Command handler functions for gameplay}
\end{itemize}

The chess program is stored in atomspace using your browser. 

If at any time you wish to reset atomspace to the default MeTTa chess program just click "Reset Atomspace" and then click "Play Chess". If "Reset Atomspace" is greyed-out, there is no need to click.

In general, if you see unexpected results or an error, try clicking "Reset Atomspace" and proceeding with examples. 

Please click "Reset Atomspace"  (if enabled) now to start with a clean slate.

\subsection{Utility Functions}

First we need to define a few general functions to be used by the whole program.

Our first couple of functions are standard LISP-ish looking tail recursion functions. In MeTTa \textbf{car-atom} and \textbf{cdr-atom} (as well as \textbf{cons-atom}) are effectively the same as LISP but with -"atom" appended. If you need a refresher or crash course in these constructs an LLM would help. \textbf{car-atom} gives you the first symbol in a list while \textbf{cdr-atom} the rest of the list, still in parenthesis. The main trick is that you code the end boundary case and the general recursive
case for items remaining in the list. Fortunately, you do less tail recursion searching in MeTTa than LISP but
it is still a handy way of looping through a list.

The chess program uses the following format for board squares:

\textbf{(x y color piece)}

If length is 4, the square is occupied. If length is 2, unoccupied. x and y are standard Cartesian coordinates.
Piece color values are either s for silver (human) or g for gold (AI). Piece types are r, n, b, q, k, p for 
rook, knight, bishop, queen, king, and pawn respectively.

The \textbf{nth} function is used constantly in the program to extract piece details. 

\begin{verbatim}
    
;***************************************************************
; Function:     nth
; Description:  Returns the N-th element from a list (1-based index).
;
; Input:        $n     - The position (1-based) of the element to return.
;               $list  - A list of elements (e.g., (a b c d)).
;
; Output:       The atom at position $n in the list. Returns the first element if n = 1.
;***************************************************************
(= (nth $n $list) 
    (if (== $n 1)
        (car-atom $list)
        (nth (- $n 1) (cdr-atom $list)))) ; Recursion: move to the next element (cdr-atom) and decrease n.

;***************************************************************
; Function:     contains_symbol
; Description:  Checks whether a given symbol exists in a list.
;
; Input:        $list - A list of atoms (e.g., (a b c d))
;               $sym  - A symbol to search for in the list
;
; Output:       True if $sym is found in $list; otherwise False
;***************************************************************
(= (contains_symbol $list $sym) 
    (if (== $list ())
        False
        (if (== (car-atom $list) $sym)
            True
            (contains_symbol (cdr-atom $list) $sym))))

;***************************************************************
; Function:     addit_list
; Description:  Computes the sum of a list of integers.
;
; Input:        $integer_list - A list of integers (e.g., (1 2 3 4))
;
; Output:       The total sum of all integers in the list (e.g., 10)
;***************************************************************
(= (addit_list $integer_list)
    (if (== $integer_list ())
        0
        (+ (car-atom $integer_list) (addit_list (cdr-atom $integer_list)))))

; find x axis value for this silver pawn located in square (2, 2)
!(nth 1 (2 2 s p))   

; see if there is a gold piece in board square (1 8) 
!(contains_symbol (1 8) g)

; add up a list of numbers
!(addit_list (4 7 1 20))

\end{verbatim}

Just a reminder that if you seem to be getting far too many results, especially of the same value, it is because whenever you click "Run" to execute the code box MeTTa will add the functions inside the box to
atomspace. Two versions of \textbf{nth} will give you multiple results. All you need to do is click "Reset Atomspace" regularly to avoid this problem. 

Our next function \textbf{int_to_char} is a simple case statement to determine the x-axis letter that 
corresponds to the numeric Cartesian x value. The program returns conventional letters for the chess x-axis.

\begin{verbatim}
   
;***************************************************************
; Function:     int_to_char
; Description:  Converts an integer 1..8 to the corresponding incremental letter.
;
; Input:        $int - Integer in range 1 to 8
;
; Output:       Corresponding file letter "a".."h", or "?" if invalid
;***************************************************************
(= (int_to_char $int)
    (case $int
        (
        (1 A)
        (2 B)
        (3 C)
        (4 D)
        (5 E)
        (6 F)
        (7 G)
        (8 H)
        ($_ ?) ; fallback for invalid input
        )))

;example look up        
!(int_to_char 5)
\end{verbatim}

\subsection{Declaring Constants and Initialization for the Run}

An easy way to define constants is just by coding them. These can be looked up in the \textbf{&self} 
space using \textbf{match}.

\begin{verbatim}
;*******************************************************
; Constants 
;*******************************************************

(highestrank k) 
(highrank q) 
(medrank r) 
(medrank b) 
(medrank n) 
(lowrank p) 

(rank k) 
(rank q) 
(rank r) 
(rank b) 
(rank n) 
(rank p) 

;example to return all ranks in a list. You get all ranks because MeTTa insists on giving all the results!
!(collapse (match &self (rank $rank) $rank))
\end{verbatim}

The following expression adds an atom for game state. It's not a constant since we will be changing it later
by removing and adding an atom of the form "(game-state -value-)".

\begin{verbatim}

;*******************************************************
; Declare initializing game state
;*******************************************************

(game-state initializing)

; in this example query, we look up game-state, remove it, then add a new game state.
; progn works nicely for running a sequence of expressions.
!(match &self (game-state $state) 
    (progn 
        (remove-atom (game-state $state))
        (add-atom (game-state started))))

\end{verbatim}

\subsection{Putting It All Together}



\begin{verbatim}
(end)
\end{verbatim}

Summary


\end{document}
